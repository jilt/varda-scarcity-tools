
// Code generated by zane generator DO NOT EDIT.
import { RequestManager, PostMessageWindowTransport, PostMessageIframeTransport, WebSocketTransport, HTTPTransport, Client, JSONRPCError } from "@open-rpc/client-js";
import _ from "lodash";
import { OpenrpcDocument as OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator, MethodNotFoundError } from "@open-rpc/schema-utils-js";
import { Account, Near, Contract} from "near-api-js";
import BN from "bn.js"

/**
 *
 * AccountId for the near account
 *
 */
export type AccountId = string;
export type SaleId = string;
/**
 *
 * expected approval ID. A number smaller than 2^53
 *
 */
export type ApprovalId = number;
/**
 *
 * Token identifier that corresponds to an id
 *
 */
export type TokenId = string;
export type AccountCondition = string;
/**
 *
 * U128 integer as string
 *
 */
export type U128 = string;
export interface Bid {
  owner_id?: AccountId;
  amount?: U128;
  [k: string]: any;
}
export interface FtSaleConditions {
  [k: string]: any;
}
export type TokenIdRegex = string;
/**
 *
 * ex. Parcel #5055
 *
 */
export type NFTTokenMetadataTitle = string;
/**
 *
 * free-form description
 *
 */
export type NFTTokenMetadataDesc = string;
/**
 *
 * URL to associated media, preferably to decentralized, content-addressed storage
 *
 */
export type NFTTokenMetadataMedia = string;
/**
 *
 * Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
 *
 */
export type NFTTokenMetadataMediaHash = string;
/**
 *
 * When token was issued or minted, Unix epoc in milliseconds
 *
 */
export type NFTokenMetadataIssuedAt = string;
/**
 *
 * When token expires, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataExpiresAt = string;
/**
 *
 * When token starts being valid, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataStartsAt = string;
/**
 *
 * When token was last updated, Unix epoch in milliseconds
 *
 */
export type NFTokenMetadataUpdatedAt = string;
/**
 *
 * Anything extra the MT wants to store on-chain. Can be stringified JSON.
 *
 */
export type NFTokenMetadataExtra = string;
/**
 *
 * URL to an off-chain JSON file with more info.
 *
 */
export type NFTokenMetadataReference = string;
/**
 *
 * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
 *
 */
export type NFTokenMetadataReferenceHash = string;
export interface NFTTokenMetadata {
  title?: NFTTokenMetadataTitle;
  description?: NFTTokenMetadataDesc;
  media?: NFTTokenMetadataMedia;
  media_hash?: NFTTokenMetadataMediaHash;
  issued_at?: NFTokenMetadataIssuedAt;
  expires_at?: NFTokenMetadataExpiresAt;
  starts_at?: NFTokenMetadataStartsAt;
  updated_at?: NFTokenMetadataUpdatedAt;
  extra?: NFTokenMetadataExtra;
  reference?: NFTokenMetadataReference;
  reference_hash?: NFTokenMetadataReferenceHash;
  [k: string]: any;
}
export interface NftMetadataFilter {
  token_id?: TokenId;
  token_id_regex?: TokenIdRegex;
  metadata?: NFTTokenMetadata;
}
export interface NftSaleConditions {
  [regex: string]: NftMetadataFilter | any;
}
export interface SaleCondition {
  ft?: FtSaleConditions;
  nft?: NftSaleConditions;
  [k: string]: any;
}
export type SaleConditions = [SaleCondition];
export type BooleanVyG3AETh = boolean;
export interface ItemForSale {
  contract_id: AccountId;
  token_id: TokenId;
  [k: string]: any;
}
/**
 *
 * U64 integer as string
 *
 */
export type U64 = string;
export interface Sale {
  owner_id: AccountId;
  account_condition?: AccountId;
  approval_id?: ApprovalId;
  item_for_sale: ItemForSale;
  sale_id: SaleId;
  service_fee?: U128;
  sale_conditions?: SaleConditions;
  created_at: U64;
  [k: string]: any;
}
export type AccountIds = [AccountId];
export type BidHistoryLength = number;
export interface NftBuyOffer {
  sale_id: SaleId;
  approval_id?: ApprovalId;
  contract_id: AccountId;
  token_id?: TokenId;
  [k: string]: any;
}
export interface SaleArgs {
  account_condition?: AccountCondition;
  sale_conditions: SaleConditions;
  [k: string]: any;
}
export interface SaleItem {
  contract_id: AccountId;
  token_id?: TokenId;
  [k: string]: any;
}
/**
 *
 * Limit for setting pagination u64 constrainted by 2^53 js limit
 *
 */
export type Limit = number;
export type TokenIds = [TokenId];
export type NullQu0Arl1F = null;
export type Booleans = [BooleanVyG3AETh];
export type Sales = [Sale];
export type NumberHo1ClIqD = number;
export interface StorageBalanceBoundsObject {
  min?: U128;
  max?: U128;
  [k: string]: any;
}
export interface StorageBalance {
  total: U128;
  available: U128;
  [k: string]: any;
}
export type UnorderedSetOfBooleanVyG3AETheht2BVDp = [BooleanVyG3AETh];
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfAccountIdAccountIdsBidHistoryLengthAccountIdsAccountIdTokenIdNftBuyOfferSaleArgsSaleItemApprovalIdAccountIdTokenIdTokenIdAccountIdTokenIdAccountIdU128SaleIdU128SaleIdU64LimitAccountIdU64LimitAccountIdU64LimitAccountIdU64LimitAccountIdTokenIdU64LimitAccountIdAccountIdAccountIdAccountIdBooleanVyG3AEThBooleanVyG3AEThTokenIdsU128NullQu0Arl1FBooleansNullQu0Arl1FNullQu0Arl1FSaleIdNullQu0Arl1FNullQu0Arl1FNullQu0Arl1FU128SaleSalesNumberHo1ClIqDSalesSalesSalesSalesU64U64U64StorageBalanceBoundsObjectStorageBalanceStorageBalanceUnorderedSetOfBooleanVyG3AETheht2BVDpStorageBalance = AccountId | AccountIds | BidHistoryLength | TokenId | NftBuyOffer | SaleArgs | SaleItem | ApprovalId | U128 | SaleId | U64 | Limit | BooleanVyG3AETh | TokenIds | NullQu0Arl1F | Booleans | Sale | Sales | NumberHo1ClIqD | StorageBalanceBoundsObject | StorageBalance | UnorderedSetOfBooleanVyG3AETheht2BVDp;
export type New = (owner_id: AccountId, ft_token_ids?: AccountIds, bid_history_length?: BidHistoryLength) => Promise<NullQu0Arl1F>;
export type AddFtTokenIds = (ft_token_ids: AccountIds) => Promise<Booleans>;
export type Offer = (nft_contract_id: AccountId, token_id: TokenId) => Promise<NullQu0Arl1F>;
export type NftOffer = (offer: NftBuyOffer) => Promise<NullQu0Arl1F>;
export type NftList = (sale_args: SaleArgs, sale_item: SaleItem, sale_approval_id?: ApprovalId) => Promise<SaleId>;
export type AcceptOffer = (nft_contract_id: AccountId, token_id: TokenId, ft_token_id: TokenId) => Promise<NullQu0Arl1F>;
export type UpdatePrice = (nft_contract_id: AccountId, token_id: TokenId, ft_token_id: AccountId, price: U128) => Promise<NullQu0Arl1F>;
export type RemoveSale = (sale_id: SaleId) => Promise<NullQu0Arl1F>;
export type GetFee = (amount: U128) => Promise<U128>;
export type GetSale = (sale_id: SaleId) => Promise<Sale>;
export type GetSales = (from_index: U64, limit: Limit) => Promise<Sales>;
export type GetNumSales = () => Promise<NumberHo1ClIqD>;
export type GetSalesByOwnerId = (account_id: AccountId, from_index: U64, limit: Limit) => Promise<Sales>;
export type GetSalesForOwnerId = (account_id: AccountId, from_index: U64, limit: Limit) => Promise<Sales>;
export type GetSalesByNftContractId = (nft_contract_id: AccountId, from_index: U64, limit: Limit) => Promise<Sales>;
export type GetOffersByContractTokenId = (contract_id: AccountId, token_id: TokenId, from_index: U64, limit: Limit) => Promise<Sales>;
export type GetSupplyByOwnerId = (account_id?: AccountId) => Promise<U64>;
export type GetSupplyByNftContractId = (nft_contract_id: AccountId) => Promise<U64>;
export type GetSupplySales = () => Promise<U64>;
export type StorageBalanceBounds = () => Promise<StorageBalanceBoundsObject>;
export type StorageBalanceOf = (account_id: AccountId) => Promise<StorageBalance>;
export type StorageDeposit = (account_id?: AccountId, registration_only?: BooleanVyG3AETh) => Promise<StorageBalance>;
export type StorageUnregister = (force?: BooleanVyG3AETh) => Promise<UnorderedSetOfBooleanVyG3AETheht2BVDp>;
export type StorageWithdraw = (token_ids: TokenIds, amount: U128) => Promise<StorageBalance>;

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNew = [...Parameters<New>, ChangeMethodOptions?]
  type RTNew = ReturnType<New>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTAddFtTokenIds = [...Parameters<AddFtTokenIds>, ChangeMethodOptions?]
  type RTAddFtTokenIds = ReturnType<AddFtTokenIds>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTOffer = [...Parameters<Offer>, ChangeMethodOptions?]
  type RTOffer = ReturnType<Offer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftOffer = [...Parameters<NftOffer>, ChangeMethodOptions?]
  type RTNftOffer = ReturnType<NftOffer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTNftList = [...Parameters<NftList>, ChangeMethodOptions?]
  type RTNftList = ReturnType<NftList>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTAcceptOffer = [...Parameters<AcceptOffer>, ChangeMethodOptions?]
  type RTAcceptOffer = ReturnType<AcceptOffer>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTUpdatePrice = [...Parameters<UpdatePrice>, ChangeMethodOptions?]
  type RTUpdatePrice = ReturnType<UpdatePrice>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTRemoveSale = [...Parameters<RemoveSale>, ChangeMethodOptions?]
  type RTRemoveSale = ReturnType<RemoveSale>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetFee = [...Parameters<GetFee>, ChangeMethodOptions?]
  type RTGetFee = ReturnType<GetFee>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSale = [...Parameters<GetSale>, ChangeMethodOptions?]
  type RTGetSale = ReturnType<GetSale>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSales = [...Parameters<GetSales>, ChangeMethodOptions?]
  type RTGetSales = ReturnType<GetSales>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetNumSales = [...Parameters<GetNumSales>, ChangeMethodOptions?]
  type RTGetNumSales = ReturnType<GetNumSales>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSalesByOwnerId = [...Parameters<GetSalesByOwnerId>, ChangeMethodOptions?]
  type RTGetSalesByOwnerId = ReturnType<GetSalesByOwnerId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSalesForOwnerId = [...Parameters<GetSalesForOwnerId>, ChangeMethodOptions?]
  type RTGetSalesForOwnerId = ReturnType<GetSalesForOwnerId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSalesByNftContractId = [...Parameters<GetSalesByNftContractId>, ChangeMethodOptions?]
  type RTGetSalesByNftContractId = ReturnType<GetSalesByNftContractId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetOffersByContractTokenId = [...Parameters<GetOffersByContractTokenId>, ChangeMethodOptions?]
  type RTGetOffersByContractTokenId = ReturnType<GetOffersByContractTokenId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSupplyByOwnerId = [...Parameters<GetSupplyByOwnerId>, ChangeMethodOptions?]
  type RTGetSupplyByOwnerId = ReturnType<GetSupplyByOwnerId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSupplyByNftContractId = [...Parameters<GetSupplyByNftContractId>, ChangeMethodOptions?]
  type RTGetSupplyByNftContractId = ReturnType<GetSupplyByNftContractId>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTGetSupplySales = [...Parameters<GetSupplySales>, ChangeMethodOptions?]
  type RTGetSupplySales = ReturnType<GetSupplySales>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageBalanceBounds = [...Parameters<StorageBalanceBounds>, ChangeMethodOptions?]
  type RTStorageBalanceBounds = ReturnType<StorageBalanceBounds>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageBalanceOf = [...Parameters<StorageBalanceOf>, ChangeMethodOptions?]
  type RTStorageBalanceOf = ReturnType<StorageBalanceOf>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageDeposit = [...Parameters<StorageDeposit>, ChangeMethodOptions?]
  type RTStorageDeposit = ReturnType<StorageDeposit>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageUnregister = [...Parameters<StorageUnregister>, ChangeMethodOptions?]
  type RTStorageUnregister = ReturnType<StorageUnregister>

  /**
   * Generated typings 
   */
  // tslint:disable-next-line:max-line-length
  type GTStorageWithdraw = [...Parameters<StorageWithdraw>, ChangeMethodOptions?]
  type RTStorageWithdraw = ReturnType<StorageWithdraw>


export interface Options {
    account: Account;
    contractId: string;
}

export type NearNumber = BN | string | number;

export interface ChangeMethodOptions {
  gas?: NearNumber 
  amount?: NearNumber
}

const isMetaObject = (x: any): boolean => {
  if(x && (x.gas || x.amount)) return true
  return false
}

export class SwapplandMarket {
  public static openrpcDocument: OpenRPC = {"openrpc":"1.0.0","info":{"title":"SwapplandMarket","version":"0.0.0-development"},"methods":[{"name":"new","summary":"Instantiate market contract","description":"Instantiate market contract","tags":[{"name":"change","description":"change method"}],"params":[{"name":"owner_id","summary":"The owner of the contract","description":"The owner of the contract","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"ft_token_ids","summary":"Fungible tokens to support","description":"Fungible tokens to support","schema":{"title":"AccountIds","type":"array","items":[{"title":"AccountId","type":"string","description":"AccountId for the near account"}]},"required":false},{"name":"bid_history_length","summary":"The bid history length","description":"The bid history length","schema":{"title":"BidHistoryLength","minimum":0,"maximum":255,"type":"integer"},"required":false}],"result":{"name":"MarketSimpleNewResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"add_ft_token_ids","summary":"Add tokens to accept as currency","description":"Add tokens to accept as currency","tags":[{"name":"change","description":"change method"}],"params":[{"name":"ft_token_ids","summary":"Fungible tokens to support","description":"Fungible tokens to support","schema":{"title":"AccountIds","type":"array","items":[{"title":"AccountId","type":"string","description":"AccountId for the near account"}]},"required":true}],"result":{"name":"MarketSimpleBoolsResult","summary":"Returns whether or not tokens were added","description":"Returns whether or not tokens were added","schema":{"title":"Booleans","type":"array","items":[{"type":"boolean","title":"boolean_vyG3AETh"}]}}},{"name":"offer","summary":"Offer a token id ","description":"Remove sale from market place","tags":[{"name":"change","description":"change method"}],"params":[{"name":"nft_contract_id","summary":"Non fungible contract id","description":"Fungible tokens to support","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"NFT token id to support","description":"NFT token id to support","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true}],"result":{"name":"MarketSimpleOfferSalesResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"nft_offer","summary":"NFT token offer","description":"Accept nft token offer","tags":[{"name":"change","description":"change method"}],"params":[{"name":"offer","summary":"Non fungible token offer","description":"Non fungible token offer","schema":{"title":"NftBuyOffer","type":"object","properties":{"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["sale_id","contract_id"]},"required":true}],"result":{"name":"MarketSimpleNftOfferResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"nft_list","summary":"List your nft/ft for sale for an nft/ft","description":"List your nft/ft for sale for an nft/ft","tags":[{"name":"change","description":"change method"}],"params":[{"name":"sale_args","summary":"Sale conditions required for sale aka. what you're looking for","description":"sale conditions required for sale","schema":{"title":"SaleArgs","type":"object","properties":{"account_condition":{"title":"AccountCondition","type":"string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]}},"required":["sale_conditions"]},"required":true},{"name":"sale_item","summary":"The item being listed for sale","description":"The item being listed for sale","schema":{"title":"SaleItem","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id"]},"required":true},{"name":"sale_approval_id","summary":"The approval id for the item being sold","description":"The approval id for the item being sold","schema":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"required":false}],"result":{"name":"MarketSimpleNftListResult","summary":"Returns the sales id ","description":"The sales_id for the listing","schema":{"title":"SaleId","type":"string","$comment":"U64 string"}}},{"name":"accept_offer","summary":"Accept a token offer","description":"Accept a token offer","tags":[{"name":"change","description":"change method"}],"params":[{"name":"nft_contract_id","summary":"Non fungible contract id","description":"Fungible tokens to support","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"NFT token id to support","description":"NFT token id to support","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"ft_token_id","summary":"FT token id to accept offer from","description":"FT token id to accept offer from","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true}],"result":{"name":"MarketSimpleAcceptOfferSalesResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"update_price","summary":"Update the price","description":"Remove sale from market place","tags":[{"name":"change","description":"change method"}],"params":[{"name":"nft_contract_id","summary":"Non fungible contract id","description":"Fungible tokens to support","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"NFT token id to support","description":"NFT token id to support","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"ft_token_id","summary":"FT token id to support","description":"FT token id to support","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"price","summary":"Price in the denomination of the token","description":"Price in the denomination of the token","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true}],"result":{"name":"MarketSimpleUpdatePriceResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"remove_sale","summary":"Remove sale from market place","description":"Remove sale from market place","tags":[{"name":"change","description":"change method"}],"params":[{"name":"sale_id","summary":"Sale id for removal","description":"Sale id for removing the associated sale","schema":{"title":"SaleId","type":"string","$comment":"U64 string"},"required":true}],"result":{"name":"MarketSimpleRmSalesResult","summary":"Void","description":"Void","schema":{"type":"null","title":"null_Qu0Arl1F"}}},{"name":"get_fee","summary":"Get fee associated with ft transfer","description":"Get fee associated with ft transfer","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"amount","summary":"Amount used to determine fee","description":"Amount used to determine fee","schema":{"title":"U128","type":"string","description":"U128 integer as string"},"required":true}],"result":{"name":"MarketSimpleFeeResult","summary":"Fee owed for contract deposit","description":"Fee owed for contract deposit","required":false,"schema":{"title":"U128","type":"string","description":"U128 integer as string"}}},{"name":"get_sale","summary":"Get sales by nft contract id","description":"Get sales by nft contract id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"sale_id","summary":"SaleId sale id to retrieve sale","description":"sale id to retrieve sale","schema":{"title":"SaleId","type":"string","$comment":"U64 string"},"required":true}],"result":{"name":"MarketSimpleSalesByNFTContractResult","summary":"Sales","required":false,"description":"Sales by owner in a vector","schema":{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}}},{"name":"get_sales","summary":"Get sales with pagination","description":"Get sales with pagination","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"from_index","summary":"From index value","description":"From index value","schema":{"title":"U64","type":"string","description":"U64 integer as string"},"required":true},{"name":"limit","summary":"Limit to set iteration to rel. to index ","description":"Limit to set iteration to rel. to index","schema":{"title":"Limit","description":"Limit for setting pagination u64 constrainted by 2^53 js limit","type":"integer"},"required":true}],"result":{"name":"MarketSimpleSalesResult","summary":"Sales","description":"Sales by contract token id in a vector","schema":{"title":"Sales","type":"array","items":[{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}]}}},{"name":"get_num_sales","summary":"Get number of sales ","description":"Get number of sales ","tags":[{"name":"view","description":"View only methods"}],"params":[],"result":{"name":"MarketSimpleNumSalesResult","summary":"Supply of sales","description":"Supply of sales","schema":{"type":"number","title":"number_Ho1clIqD"}}},{"name":"get_sales_by_owner_id","summary":"Get sales  by owner id","description":"Get sales by owner id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"account_id","summary":"Owner account id","description":"Owner account id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"from_index","summary":"From index value","description":"From index value","schema":{"title":"U64","type":"string","description":"U64 integer as string"},"required":true},{"name":"limit","summary":"Limit to set iteration to rel. to index ","description":"Limit to set iteration to rel. to index","schema":{"title":"Limit","description":"Limit for setting pagination u64 constrainted by 2^53 js limit","type":"integer"},"required":true}],"result":{"name":"MarketSimpleSalesByOwnerResult","summary":"Sales","description":"Sales by owner in a vector","schema":{"title":"Sales","type":"array","items":[{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}]}}},{"name":"get_sales_for_owner_id","summary":"Get sales for owner id","description":"Get sales for owner id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"account_id","summary":"Potential Owner account id","description":"Potential Owner account id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"from_index","summary":"From index value","description":"From index value","schema":{"title":"U64","type":"string","description":"U64 integer as string"},"required":true},{"name":"limit","summary":"Limit to set iteration to rel. to index ","description":"Limit to set iteration to rel. to index","schema":{"title":"Limit","description":"Limit for setting pagination u64 constrainted by 2^53 js limit","type":"integer"},"required":true}],"result":{"name":"MarketSimpleSalesForOwnerResult","summary":"Sales","description":"Sales by owner in a vector","schema":{"title":"Sales","type":"array","items":[{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}]}}},{"name":"get_sales_by_nft_contract_id","summary":"Get sales by nft contract id","description":"Get sales by nft contract id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"nft_contract_id","summary":"NFT contract id","description":"NFT contract id to query against","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"from_index","summary":"From index value","description":"From index value","schema":{"title":"U64","type":"string","description":"U64 integer as string"},"required":true},{"name":"limit","summary":"Limit to set iteration to rel. to index ","description":"Limit to set iteration to rel. to index","schema":{"title":"Limit","description":"Limit for setting pagination u64 constrainted by 2^53 js limit","type":"integer"},"required":true}],"result":{"name":"MarketSimpleSalesByNFTContractResult","summary":"Sales","description":"Sales by owner in a vector","schema":{"title":"Sales","type":"array","items":[{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}]}}},{"name":"get_offers_by_contract_token_id","summary":"Get offers by contract and token id","description":"Get offers by contract and token id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"contract_id","summary":"NFT contract id","description":"NFT contract id to query against","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true},{"name":"token_id","summary":"NFT token id","description":"NFT token id to query against","schema":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"required":true},{"name":"from_index","summary":"From index value","description":"From index value","schema":{"title":"U64","type":"string","description":"U64 integer as string"},"required":true},{"name":"limit","summary":"Limit to set iteration to rel. to index ","description":"Limit to set iteration to rel. to index","schema":{"title":"Limit","description":"Limit for setting pagination u64 constrainted by 2^53 js limit","type":"integer"},"required":true}],"result":{"name":"MarketSimpleOfferByNFTContractTokenIdResult","summary":"Sales","description":"Sales by owner in a vector","schema":{"title":"Sales","type":"array","items":[{"title":"Sale","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"account_condition":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"approval_id":{"title":"ApprovalId","description":"expected approval ID. A number smaller than 2^53","type":"number"},"item_for_sale":{"title":"ItemForSale","type":"object","properties":{"contract_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}},"required":["contract_id","token_id"]},"sale_id":{"title":"SaleId","type":"string","$comment":"U64 string"},"service_fee":{"title":"U128","type":"string","description":"U128 integer as string"},"sale_conditions":{"title":"SaleConditions","type":"array","items":[{"title":"SaleCondition","type":"object","properties":{"ft":{"title":"FtSaleConditions","type":"object","properties":{},"additionalProperties":{"title":"Bid","type":"object","properties":{"owner_id":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"amount":{"title":"U128","type":"string","description":"U128 integer as string"}}}},"nft":{"title":"NftSaleConditions","type":"object","properties":{},"patternProperties":{".*":{"title":"NftMetadataFilter","type":"object","properties":{"token_id":{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"},"token_id_regex":{"title":"TokenIdRegex","type":"string"},"metadata":{"title":"NFTTokenMetadata","type":"object","properties":{"title":{"type":"string","title":"NFTTokenMetadataTitle","description":"ex. Parcel #5055"},"description":{"type":"string","title":"NFTTokenMetadataDesc","description":"free-form description"},"media":{"type":"string","title":"NFTTokenMetadataMedia","description":"URL to associated media, preferably to decentralized, content-addressed storage"},"media_hash":{"type":"string","title":"NFTTokenMetadataMediaHash","description":"Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included."},"issued_at":{"type":"string","title":"NFTokenMetadataIssuedAt","description":"When token was issued or minted, Unix epoc in milliseconds"},"expires_at":{"type":"string","title":"NFTokenMetadataExpiresAt","description":"When token expires, Unix epoch in milliseconds"},"starts_at":{"type":"string","title":"NFTokenMetadataStartsAt","description":"When token starts being valid, Unix epoch in milliseconds"},"updated_at":{"type":"string","title":"NFTokenMetadataUpdatedAt","description":"When token was last updated, Unix epoch in milliseconds"},"extra":{"type":"string","title":"NFTokenMetadataExtra","description":"Anything extra the MT wants to store on-chain. Can be stringified JSON."},"reference":{"type":"string","title":"NFTokenMetadataReference","description":"URL to an off-chain JSON file with more info."},"reference_hash":{"type":"string","title":"NFTokenMetadataReferenceHash","description":"Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included."}}}},"additionalProperties":false}},"additionalProperties":false}}}]},"created_at":{"title":"U64","type":"string","description":"U64 integer as string"}},"required":["owner_id","item_for_sale","sale_id","sales_conditions","created_at"]}]}}},{"name":"get_supply_by_owner_id","summary":"Get supply of sales  by owner id","description":"Get supply of sales by owner id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"account_id","summary":"Owner account id","description":"Owner account id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":false}],"result":{"name":"MarketSimpleSupplySalesResult","summary":"Supply of sales","description":"Supply of sales","schema":{"title":"U64","type":"string","description":"U64 integer as string"}}},{"name":"get_supply_by_nft_contract_id","summary":"Get supply by nft contract id","description":"Get supply by nft contract id","tags":[{"name":"view","description":"View only methods"}],"params":[{"name":"nft_contract_id","summary":"Nft contract id","description":"Nft contract id","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true}],"result":{"name":"MarketSimpleSupplySalesNFTResult","summary":"Supply of sales","description":"Supply of sales","schema":{"title":"U64","type":"string","description":"U64 integer as string"}}},{"name":"get_supply_sales","summary":"Get supply of sales ","description":"Get supply of sales ","tags":[{"name":"view","description":"View only methods"}],"params":[],"result":{"name":"MarketSimpleSupplySalesResult","summary":"Supply of sales","description":"Supply of sales","schema":{"title":"U64","type":"string","description":"U64 integer as string"}}},{"name":"storage_balance_bounds","summary":"Returns the minimum and maximum allowe balance amounts to interact with this contract","description":"Returns the minimum and maximum allowe balance amounts to interact with this contract","tags":[{"name":"view","description":"View only methods"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[],"result":{"name":"StorageBalanceBoundsResult","summary":"min` is the amount of tokens required to start","description":"This will  be returned for the method `storage_balance_bounds`. Both `min` and `max` are string representations of unsigned 128-bit integers.`min` is the amount of tokens required to start using this contract at all (eg to register with the contract). If a new contract user attaches `min` NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of` for this user must show their `total` equal to `min` and `available=0` .  A contract may implement `max` equal to `min` if it only charges for initial registration, and does not adjust per-user storage over time. A contract which implements `max` must refund deposits that would increase a user's storage balance beyond this amount.","schema":{"title":"StorageBalanceBoundsObject","type":"object","properties":{"min":{"title":"U128","type":"string","description":"U128 integer as string"},"max":{"title":"U128","type":"string","description":"U128 integer as string"}}}}},{"name":"storage_balance_of","summary":"Returns the storage balance of an account for set of token_ids","description":"Returns the storage balance of an account for set of token_ids. If the `account_id` is not registered it will return `null`","tags":[{"name":"view","description":"View only methods"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"account_id","summary":"Account to allocate storage for","description":"Account to allocate storage for","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":true}],"result":{"name":"StorageBalanceOfResult","summary":"Storage balance of the `account_id`","description":"Storage balance of the `account_id`","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]},"required":false}},{"name":"storage_deposit","summary":"Payable method that receives an attached deposit of Ⓝ for a given account","description":"Payable method that receives an attached deposit of Ⓝ for a given account. ","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"account_id","summary":"Account to allocate storage for","description":"Account to allocate storage for","schema":{"title":"AccountId","type":"string","description":"AccountId for the near account"},"required":false},{"name":"registration_only","summary":"Registration flag that if true will refund above minimum balance if accound didn't exist and full deposit if it exists.","description":"Registration flag that if true will refund above minimum balance if accound didn't exist and full deposit if it exists.","schema":{"type":"boolean","title":"boolean_vyG3AETh"},"required":false}],"result":{"name":"StorageDepositResult","summary":"Returns the `StorageBalance` showing updated balances","description":"Returns the `StorageBalance` showing updated balances","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]}}},{"name":"storage_unregister","summary":"Unregister the predecessor account and return the storage NEAR deposit back","description":"Unregister the predecessor account and return the storage NEAR deposit back. Requires 1yoctoNEAR attached balance to prevent function-call access-key call","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"force","summary":"The force flag set to true will ignore account balances and burn the tokens and close the account","description":"The force flag set to true will ignore account balances and burn the tokens and close the account","schema":{"type":"boolean","title":"boolean_vyG3AETh"},"required":false}],"result":{"name":"StorageUnregisterResult","summary":"An array of booleans corresponding to the `token_ids`. `false` if token was already unregistered true other wise","schema":{"type":"array","items":[{"type":"boolean","title":"boolean_vyG3AETh"}],"title":"unorderedSetOf_boolean_vyG3AETheht2bVDp"}}},{"name":"storage_withdraw","summary":"Withdraw specified amount of available Ⓝ for predecessor account.","description":"Withdraw specified amount of available Ⓝ for predecessor account. ","tags":[{"name":"change","description":"change method"},{"name":"StorageManagement","description":"Storage Management Extension Tag"}],"params":[{"name":"token_ids","summary":"The tokens to withdraw storage from","description":"The tokens to withdraw storage from","schema":{"title":"TokenIds","type":"array","items":[{"title":"TokenId","description":"Token identifier that corresponds to an id","type":"string"}]}},{"name":"amount","summary":"The amount of balance to refund","description":"The amount of balance to refund, if not specified then it's the total amount. Must require exactly 1 yoctoNEAR attached balance to prevent restricted function-call access-key call for wallet security.","schema":{"title":"U128","type":"string","description":"U128 integer as string"}}],"result":{"name":"StorageWithdrawResult","summary":"Returns the StorageBalance structure showing updated balances","schema":{"title":"StorageBalance","type":"object","properties":{"total":{"title":"U128","type":"string","description":"U128 integer as string"},"available":{"title":"U128","type":"string","description":"U128 integer as string"}},"required":["total","available"]},"required":true}}]} ;
  public contract: Contract;
  private validator: MethodCallValidator;

  constructor(options: Options) {
    const {account, contractId} = options;
    this.validator = new MethodCallValidator(SwapplandMarket.openrpcDocument);
    const changeMethods:string[] = [
      "new",
      "add_ft_token_ids",
      "offer",
      "nft_offer",
      "nft_list",
      "accept_offer",
      "update_price",
      "remove_sale",
      "storage_deposit",
      "storage_unregister",
      "storage_withdraw",
    ] 

    const viewMethods:string[] = [
      "get_fee",
      "get_sale",
      "get_sales",
      "get_num_sales",
      "get_sales_by_owner_id",
      "get_sales_for_owner_id",
      "get_sales_by_nft_contract_id",
      "get_offers_by_contract_token_id",
      "get_supply_by_owner_id",
      "get_supply_by_nft_contract_id",
      "get_supply_sales",
      "storage_balance_bounds",
      "storage_balance_of",
    ]
    this.contract = new Contract(account,contractId, {changeMethods, viewMethods})
  }

  

  /**
   * Instantiate market contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public new(owner_id: AccountId, ft_token_ids?: AccountIds, bid_history_length?: BidHistoryLength, options?: ChangeMethodOptions): RTNew { 
    //return this.request("new", params);
    const paramNames:string[] = [  
      "owner_id", 
      "ft_token_ids", 
      "bid_history_length",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).new({args: paramByName, ...options}) as RTNew 
    }

    return (this.contract as any).new({args: paramByName}) as RTNew 
  }
  

  /**
   * Add tokens to accept as currency
   * 
   */
  // tslint:disable-next-line:max-line-length
  public add_ft_token_ids(ft_token_ids: AccountIds, options?: ChangeMethodOptions): RTAddFtTokenIds { 
    //return this.request("add_ft_token_ids", params);
    const paramNames:string[] = [  
      "ft_token_ids",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).add_ft_token_ids({args: paramByName, ...options}) as RTAddFtTokenIds 
    }

    return (this.contract as any).add_ft_token_ids({args: paramByName}) as RTAddFtTokenIds 
  }
  

  /**
   * Offer a token id 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public offer(nft_contract_id: AccountId, token_id: TokenId, options?: ChangeMethodOptions): RTOffer { 
    //return this.request("offer", params);
    const paramNames:string[] = [  
      "nft_contract_id", 
      "token_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).offer({args: paramByName, ...options}) as RTOffer 
    }

    return (this.contract as any).offer({args: paramByName}) as RTOffer 
  }
  

  /**
   * NFT token offer
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_offer(offer: NftBuyOffer, options?: ChangeMethodOptions): RTNftOffer { 
    //return this.request("nft_offer", params);
    const paramNames:string[] = [  
      "offer",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_offer({args: paramByName, ...options}) as RTNftOffer 
    }

    return (this.contract as any).nft_offer({args: paramByName}) as RTNftOffer 
  }
  

  /**
   * List your nft/ft for sale for an nft/ft
   * 
   */
  // tslint:disable-next-line:max-line-length
  public nft_list(sale_args: SaleArgs, sale_item: SaleItem, sale_approval_id?: ApprovalId, options?: ChangeMethodOptions): RTNftList { 
    //return this.request("nft_list", params);
    const paramNames:string[] = [  
      "sale_args", 
      "sale_item", 
      "sale_approval_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).nft_list({args: paramByName, ...options}) as RTNftList 
    }

    return (this.contract as any).nft_list({args: paramByName}) as RTNftList 
  }
  

  /**
   * Accept a token offer
   * 
   */
  // tslint:disable-next-line:max-line-length
  public accept_offer(nft_contract_id: AccountId, token_id: TokenId, ft_token_id: TokenId, options?: ChangeMethodOptions): RTAcceptOffer { 
    //return this.request("accept_offer", params);
    const paramNames:string[] = [  
      "nft_contract_id", 
      "token_id", 
      "ft_token_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).accept_offer({args: paramByName, ...options}) as RTAcceptOffer 
    }

    return (this.contract as any).accept_offer({args: paramByName}) as RTAcceptOffer 
  }
  

  /**
   * Update the price
   * 
   */
  // tslint:disable-next-line:max-line-length
  public update_price(nft_contract_id: AccountId, token_id: TokenId, ft_token_id: AccountId, price: U128, options?: ChangeMethodOptions): RTUpdatePrice { 
    //return this.request("update_price", params);
    const paramNames:string[] = [  
      "nft_contract_id", 
      "token_id", 
      "ft_token_id", 
      "price",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).update_price({args: paramByName, ...options}) as RTUpdatePrice 
    }

    return (this.contract as any).update_price({args: paramByName}) as RTUpdatePrice 
  }
  

  /**
   * Remove sale from market place
   * 
   */
  // tslint:disable-next-line:max-line-length
  public remove_sale(sale_id: SaleId, options?: ChangeMethodOptions): RTRemoveSale { 
    //return this.request("remove_sale", params);
    const paramNames:string[] = [  
      "sale_id",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).remove_sale({args: paramByName, ...options}) as RTRemoveSale 
    }

    return (this.contract as any).remove_sale({args: paramByName}) as RTRemoveSale 
  }
  

  /**
   * Get fee associated with ft transfer
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_fee(amount: U128): RTGetFee { 
    //return this.request("get_fee", params);
    const paramNames:string[] = [  
      "amount",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_fee({args: paramByName, ...options}) as RTGetFee 
    }

    return (this.contract as any).get_fee(paramByName) as RTGetFee 
    
  }
  

  /**
   * Get sales by nft contract id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_sale(sale_id: SaleId): RTGetSale { 
    //return this.request("get_sale", params);
    const paramNames:string[] = [  
      "sale_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_sale({args: paramByName, ...options}) as RTGetSale 
    }

    return (this.contract as any).get_sale(paramByName) as RTGetSale 
    
  }
  

  /**
   * Get sales with pagination
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_sales(from_index: U64, limit: Limit): RTGetSales { 
    //return this.request("get_sales", params);
    const paramNames:string[] = [  
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_sales({args: paramByName, ...options}) as RTGetSales 
    }

    return (this.contract as any).get_sales(paramByName) as RTGetSales 
    
  }
  

  /**
   * Get number of sales 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_num_sales(): RTGetNumSales { 
    //return this.request("get_num_sales", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_num_sales({args: paramByName, ...options}) as RTGetNumSales 
    }

    return (this.contract as any).get_num_sales(paramByName) as RTGetNumSales 
    
  }
  

  /**
   * Get sales  by owner id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_sales_by_owner_id(account_id: AccountId, from_index: U64, limit: Limit): RTGetSalesByOwnerId { 
    //return this.request("get_sales_by_owner_id", params);
    const paramNames:string[] = [  
      "account_id", 
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_sales_by_owner_id({args: paramByName, ...options}) as RTGetSalesByOwnerId 
    }

    return (this.contract as any).get_sales_by_owner_id(paramByName) as RTGetSalesByOwnerId 
    
  }
  

  /**
   * Get sales for owner id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_sales_for_owner_id(account_id: AccountId, from_index: U64, limit: Limit): RTGetSalesForOwnerId { 
    //return this.request("get_sales_for_owner_id", params);
    const paramNames:string[] = [  
      "account_id", 
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_sales_for_owner_id({args: paramByName, ...options}) as RTGetSalesForOwnerId 
    }

    return (this.contract as any).get_sales_for_owner_id(paramByName) as RTGetSalesForOwnerId 
    
  }
  

  /**
   * Get sales by nft contract id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_sales_by_nft_contract_id(nft_contract_id: AccountId, from_index: U64, limit: Limit): RTGetSalesByNftContractId { 
    //return this.request("get_sales_by_nft_contract_id", params);
    const paramNames:string[] = [  
      "nft_contract_id", 
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_sales_by_nft_contract_id({args: paramByName, ...options}) as RTGetSalesByNftContractId 
    }

    return (this.contract as any).get_sales_by_nft_contract_id(paramByName) as RTGetSalesByNftContractId 
    
  }
  

  /**
   * Get offers by contract and token id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_offers_by_contract_token_id(contract_id: AccountId, token_id: TokenId, from_index: U64, limit: Limit): RTGetOffersByContractTokenId { 
    //return this.request("get_offers_by_contract_token_id", params);
    const paramNames:string[] = [  
      "contract_id", 
      "token_id", 
      "from_index", 
      "limit",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_offers_by_contract_token_id({args: paramByName, ...options}) as RTGetOffersByContractTokenId 
    }

    return (this.contract as any).get_offers_by_contract_token_id(paramByName) as RTGetOffersByContractTokenId 
    
  }
  

  /**
   * Get supply of sales  by owner id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_supply_by_owner_id(account_id?: AccountId): RTGetSupplyByOwnerId { 
    //return this.request("get_supply_by_owner_id", params);
    const paramNames:string[] = [  
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_supply_by_owner_id({args: paramByName, ...options}) as RTGetSupplyByOwnerId 
    }

    return (this.contract as any).get_supply_by_owner_id(paramByName) as RTGetSupplyByOwnerId 
    
  }
  

  /**
   * Get supply by nft contract id
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_supply_by_nft_contract_id(nft_contract_id: AccountId): RTGetSupplyByNftContractId { 
    //return this.request("get_supply_by_nft_contract_id", params);
    const paramNames:string[] = [  
      "nft_contract_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_supply_by_nft_contract_id({args: paramByName, ...options}) as RTGetSupplyByNftContractId 
    }

    return (this.contract as any).get_supply_by_nft_contract_id(paramByName) as RTGetSupplyByNftContractId 
    
  }
  

  /**
   * Get supply of sales 
   * 
   */
  // tslint:disable-next-line:max-line-length
  public get_supply_sales(): RTGetSupplySales { 
    //return this.request("get_supply_sales", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).get_supply_sales({args: paramByName, ...options}) as RTGetSupplySales 
    }

    return (this.contract as any).get_supply_sales(paramByName) as RTGetSupplySales 
    
  }
  

  /**
   * Returns the minimum and maximum allowe balance amounts to interact with this contract
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_balance_bounds(): RTStorageBalanceBounds { 
    //return this.request("storage_balance_bounds", params);
    const paramNames:string[] = [ 
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_balance_bounds({args: paramByName, ...options}) as RTStorageBalanceBounds 
    }

    return (this.contract as any).storage_balance_bounds(paramByName) as RTStorageBalanceBounds 
    
  }
  

  /**
   * Returns the storage balance of an account for set of token_ids
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_balance_of(account_id: AccountId): RTStorageBalanceOf { 
    //return this.request("storage_balance_of", params);
    const paramNames:string[] = [  
      "account_id",
    ]
    const arrArgs = Array.from(arguments); 
    const options = {}
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_balance_of({args: paramByName, ...options}) as RTStorageBalanceOf 
    }

    return (this.contract as any).storage_balance_of(paramByName) as RTStorageBalanceOf 
    
  }
  

  /**
   * Payable method that receives an attached deposit of Ⓝ for a given account
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_deposit(account_id?: AccountId, registration_only?: BooleanVyG3AETh, options?: ChangeMethodOptions): RTStorageDeposit { 
    //return this.request("storage_deposit", params);
    const paramNames:string[] = [  
      "account_id", 
      "registration_only",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_deposit({args: paramByName, ...options}) as RTStorageDeposit 
    }

    return (this.contract as any).storage_deposit({args: paramByName}) as RTStorageDeposit 
  }
  

  /**
   * Unregister the predecessor account and return the storage NEAR deposit back
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_unregister(force?: BooleanVyG3AETh, options?: ChangeMethodOptions): RTStorageUnregister { 
    //return this.request("storage_unregister", params);
    const paramNames:string[] = [  
      "force",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_unregister({args: paramByName, ...options}) as RTStorageUnregister 
    }

    return (this.contract as any).storage_unregister({args: paramByName}) as RTStorageUnregister 
  }
  

  /**
   * Withdraw specified amount of available Ⓝ for predecessor account.
   * 
   */
  // tslint:disable-next-line:max-line-length
  public storage_withdraw(token_ids: TokenIds, amount: U128, options?: ChangeMethodOptions): RTStorageWithdraw { 
    //return this.request("storage_withdraw", params);
    const paramNames:string[] = [  
      "token_ids", 
      "amount",
    ]
    const arrArgs = Array.from(arguments); 
    
    const args =  options && Object.keys(options).length ? arrArgs.slice(0, arguments.length-1) : arrArgs
    const paramByName = _.zipObject(paramNames, args);
    if (options && Object.keys(options).length) {
    return (this.contract as any).storage_withdraw({args: paramByName, ...options}) as RTStorageWithdraw 
    }

    return (this.contract as any).storage_withdraw({args: paramByName}) as RTStorageWithdraw 
  }
  
}
export default SwapplandMarket;
